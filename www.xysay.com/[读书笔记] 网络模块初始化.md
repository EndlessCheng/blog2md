title: [读书笔记] 网络模块初始化

date: 2014-10-10T18:01:23+00:00

tags: [linux, 内核, 网络协议栈, ]

description: 

---
读《Linux 内核源码剖析- TCP/IP 实现》第四章笔记。 此书用的是2.6.20的内核，我在看的同时对比了3.14.17的内核源码，所以内容有变动，都是基于3.14.17内核源码。    
有关网络的初始化过程主要由sysctl_init()和do_initcalls()完成。其中系统调用sysctl_init()是在start_kernel() ->proc_root_init()->proc_sys_init()->sysctl_init()。完成sysctl的初始化注册过程。后者进行了一系列的初始化模块： 

static char *initcall_level_names[] __initdata = { "early", "core", "postcore", "arch", "subsys", "fs", "device", "late", }; static void __init do_initcalls(void) { int level; for (level = 0; level < ARRAY_SIZE(initcall_levels) - 1; level++) do_initcall_level(level); } 

1 

2 

3 

4 

5 

6 

7 

8 

9 

10 

11 

12 

13 

14 

15 

16 

17 

| 

static  char  *  initcall_level_names  [  ]  __initdata  =  { 

"early"  , 

"core"  , 

"postcore"  , 

"arch"  , 

"subsys"  , 

"fs"  , 

"device"  , 

"late"  , 

}  ; 

static  void  __init  do_initcalls  (  void  ) 

{ 

int  level  ; 

for  (  level  =  0  ;  level  < ARRAY_SIZE  (  initcall_levels  )  \-  1  ;  level  ++  ) 

do_initcall_level  (  level  )  ; 

}   
  
---|---  
  
对模块的初始化，一般是通过module_init宏来登记初始化函数。对于静态编译到内核中的驱动程序模块，module_init宏指示编译器把模块的入口函数放到一个特殊的段中，在内核初始化过程中，由do_initcalls()调用这些函数从而达到初始化的效果。Module_init宏定义在include/linux/init.h中 

typedef int (*initcall_t)(void); … #define __define_initcall(fn, id) \ static initcall_t __initcall_##fn##id __used \ __attribute__((__section__(".initcall" #id ".init"))) = fn … #define device_initcall(fn) __define_initcall(fn, 6) … #define __initcall(fn) device_initcall(fn) … #define module_init(x) __initcall(x); 

1 

2 

3 

4 

5 

6 

7 

8 

9 

10 

11 

| 

typedef  int  (  *  initcall_t  )  (  void  )  ; 

… 

#define __define_initcall(fn, id) \ 

static  initcall_t  __initcall_  ##fn##id __used \ 

__attribute__  (  (  __section__  (  ".initcall"  #id ".init"))) = fn 

… 

#define device_initcall(fn) __define_initcall(fn, 6) 

… 

#define __initcall(fn) device_initcall(fn) 

… 

#define module_init(x) __initcall(x);   
  
---|---  
  
其中INITCALLS定义在vmlinux.lds.h (include\asm-generic) 

#define INIT_CALLS_LEVEL(level) \ VMLINUX_SYMBOL(__initcall##level##_start) = .; \ *(.initcall##level##.init) \ *(.initcall##level##s.init) \ #define INIT_CALLS \ VMLINUX_SYMBOL(__initcall_start) = .; \ *(.initcallearly.init) \ INIT_CALLS_LEVEL(0) \ INIT_CALLS_LEVEL(1) \ INIT_CALLS_LEVEL(2) \ INIT_CALLS_LEVEL(3) \ INIT_CALLS_LEVEL(4) \ INIT_CALLS_LEVEL(5) \ INIT_CALLS_LEVEL(rootfs) \ INIT_CALLS_LEVEL(6) \ INIT_CALLS_LEVEL(7) \ VMLINUX_SYMBOL(__initcall_end) = .; 

1 

2 

3 

4 

5 

6 

7 

8 

9 

10 

11 

12 

13 

14 

15 

16 

17 

18 

| 

#define INIT_CALLS_LEVEL(level) \ 

VMLINUX_SYMBOL  (  __initcall  ##level##_start) = .; \ 

*  (  .  initcall  ##level##.init) \ 

*  (  .  initcall  ##level##s.init) \ 

#define INIT_CALLS \ 

VMLINUX_SYMBOL  (  __initcall_start  )  =  .  ;  \ 

*  (  .  initcallearly  .  init  )  \ 

INIT_CALLS_LEVEL  (  0  )  \ 

INIT_CALLS_LEVEL  (  1  )  \ 

INIT_CALLS_LEVEL  (  2  )  \ 

INIT_CALLS_LEVEL  (  3  )  \ 

INIT_CALLS_LEVEL  (  4  )  \ 

INIT_CALLS_LEVEL  (  5  )  \ 

INIT_CALLS_LEVEL  (  rootfs  )  \ 

INIT_CALLS_LEVEL  (  6  )  \ 

INIT_CALLS_LEVEL  (  7  )  \ 

VMLINUX_SYMBOL  (  __initcall_end  )  =  .  ;   
  
---|---  
  
__initcall_start和__initcall_end来记录.initcall.init的起始结束地址。这个我们可以在编译后的vmlinux.lds中看到： 

:init .init.data : AT(ADDR(.init.data) - 0xffffffff80000000) { *(.init.data) . = ALIGN(8); __start_mcount_loc = .; *(__mcount_loc) __stop_mcount_loc = .; *(.init.rodata) . = ALIGN(8); __start_ftrace_events = .; *(_ftrace_events) __stop_ftrace_events = .; . = ALIGN(8); __start_syscalls_metadata = .; *(__syscalls_metadata) __stop_syscalls_metadata = .; . = ALIGN(8); __clk_of_table = .; *(__clk_of_table) *(__clk_of_table_end) . = ALIGN(32); __dtb_start = .; *(.dtb.init.rodata) __dtb_end = .; . = ALIGN(16); __setup_start = .; *(.init.setup) __setup_end = .; __initcall_start = .; *(.initcallearly.init) __initcall0_start = .; *(.initcall0.init) *(.initcall0s.init) __initcall1_start = .; *(.initcall1.init) *(.initcall1s.init) __initcall2_start = .; *(.initcall2.init) *(.initcall2s.init) __initcall3_start = .; *(.initcall3.init) *(.initcall3s.init) __initcall4_start = .; *(.initcall4.init) *(.initcall4s.init) __initcall5_start = .; *(.initcall5.init) *(.initcall5s.init) __initcallrootfs_start = .; *(.initcallrootfs.init) *(.initcallrootfss.init) __initcall6_start = .; *(.initcall6.init) *(.initcall6s.init) __initcall7_start = .; *(.initcall7.init) *(.initcall7s.init) __initcall_end = .; __con_initcall_start = .; *(.con_initcall.init) __con_initcall_end = .; __security_initcall_start = .; *(.security_initcall.init) __security_initcall_end = .; . = ALIGN(4); __initramfs_start = .; *(.init.ramfs) . = ALIGN(8); *(.init.ramfs.info) } 

1 

2 

| 

:  init 

.  init  .  data  :  AT  (  ADDR  (  .  init  .  data  )  \-  0xffffffff80000000  )  {  *  (  .  init  .  data  )  .  =  ALIGN  (  8  )  ;  __start_mcount_loc  =  .  ;  *  (  __mcount_loc  )  __stop_mcount_loc  =  .  ;  *  (  .  init  .  rodata  )  .  =  ALIGN  (  8  )  ;  __start_ftrace_events  =  .  ;  *  (  _ftrace_events  )  __stop_ftrace_events  =  .  ;  .  =  ALIGN  (  8  )  ;  __start_syscalls_metadata  =  .  ;  *  (  __syscalls_metadata  )  __stop_syscalls_metadata  =  .  ;  .  =  ALIGN  (  8  )  ;  __clk_of_table  =  .  ;  *  (  __clk_of_table  )  *  (  __clk_of_table_end  )  .  =  ALIGN  (  32  )  ;  __dtb_start  =  .  ;  *  (  .  dtb  .  init  .  rodata  )  __dtb_end  =  .  ;  .  =  ALIGN  (  16  )  ;  __setup_start  =  .  ;  *  (  .  init  .  setup  )  __setup_end  =  .  ;  __initcall_start  =  .  ;  *  (  .  initcallearly  .  init  )  __initcall0_start  =  .  ;  *  (  .  initcall0  .  init  )  *  (  .  initcall0s  .  init  )  __initcall1_start  =  .  ;  *  (  .  initcall1  .  init  )  *  (  .  initcall1s  .  init  )  __initcall2_start  =  .  ;  *  (  .  initcall2  .  init  )  *  (  .  initcall2s  .  init  )  __initcall3_start  =  .  ;  *  (  .  initcall3  .  init  )  *  (  .  initcall3s  .  init  )  __initcall4_start  =  .  ;  *  (  .  initcall4  .  init  )  *  (  .  initcall4s  .  init  )  __initcall5_start  =  .  ;  *  (  .  initcall5  .  init  )  *  (  .  initcall5s  .  init  )  __initcallrootfs_start  =  .  ;  *  (  .  initcallrootfs  .  init  )  *  (  .  initcallrootfss  .  init  )  __initcall6_start  =  .  ;  *  (  .  initcall6  .  init  )  *  (  .  initcall6s  .  init  )  __initcall7_start  =  .  ;  *  (  .  initcall7  .  init  )  *  (  .  initcall7s  .  init  )  __initcall_end  =  .  ;  __con_initcall_start  =  .  ;  *  (  .  con_initcall  .  init  )  __con_initcall_end  =  .  ;  __security_initcall_start  =  .  ;  *  (  .  security_initcall  .  init  )  __security_initcall_end  =  .  ;  .  =  ALIGN  (  4  )  ;  __initramfs_start  =  .  ;  *  (  .  init  .  ramfs  )  .  =  ALIGN  (  8  )  ;  *  (  .  init  .  ramfs  .  info  )  }   
  
---|---  
  
定义模块加载函数的宏module_init被定义在include/linux/init.h中 

/* Each module must use one module_init(). */ #define module_init(initfn) \ static inline initcall_t __inittest(void) \ { return initfn; } \ int init_module(void) __attribute__((alias(#initfn))); 

1 

2 

3 

4 

5 

| 

/* Each module must use one module_init(). */ 

#define module_init(initfn) \ 

static  inline  initcall_t  __inittest  (  void  )  \ 

{  return  initfn  ;  }  \ 

int  init_module  (  void  )  __attribute__  (  (  alias  (  #initfn)));   
  
---|---  
  
关于网络的一些初始化函数： 

  * subsys_initcall(proto_init):套接口层的初始化函数 
  * fs_initcall(inet_init)：传输层的初始化函数 
  * subsys_initcall(net_dev_init)：Internet协议簇的初始化函数 
  * core_initcall(sock_init)：设备处理层的初始化函数 
  * module_init(e100_init_module)：e100型号的网络设备驱动的初始化函数 

其中sock_init(),proto_init(),inet_init()初始化函数涉及网络的三层、四层协议。 
